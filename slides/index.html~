<!DOCTYPE html>
<!--PDF export:

* set screen-resolution to 1024x768
* open index.html in google-chrome
* print to PDF
https://github.com/gnab/remark/issues/50


TODO:
* movie with high hourly frequency
* validation
* Details about KF and EnKF
* validation with 15 profiles
* more satellite data



* localization
* strong coupling between different variables
* model assumed to be too perfect
* delicate balance between models

 -->
<html>
  <head>
    <title>Stochastic parametrization of model errors</title>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
    <style type="text/css">
      @font-face{
        font-family: 'Droid Serif';
        src: url('Fonts/DroidSerif.ttf');
      }

      @font-face{
        font-family: 'Droid Serif';
        src: url('Fonts/DroidSerif-Bold.ttf');
        font-weight: bold;
      }

      @font-face{
        font-family: 'Droid Serif';
        src: url('Fonts/DroidSerif-Italic.ttf');
        font-style: italic;
      }

      @font-face{
        font-family: 'Droid Serif';
        src: url('Fonts/DroidSerif-BoldItalic.ttf');
        font-weight: bold;
        font-style: italic;
      }

      @font-face{
        font-family: 'Droid Sans';
        src: url('Fonts/DroidSans.ttf');
      }

      @font-face{
        font-family: 'Droid Sans';
        src: url('Fonts/DroidSans-Bold.ttf');
        font-weight: bold;
      }

      @font-face{
        font-family: 'Droid Sans';
        src: url('Fonts/DroidSans-Italic.ttf');
        font-style: italic;
      }

      @font-face{
        font-family: 'Droid Sans';
        src: url('Fonts/DroidSans-BoldItalic.ttf');
        font-weight: bold;
        font-style: italic;
      }

      @font-face{
        font-family: 'Yanone Kaffeesatz';
        src: url('Fonts/YanoneKaffeesatz-Regular.ttf');
      }
      @font-face{
        font-family: 'Ubuntu Mono';
        src: url('Fonts/UbuntuMono-Regular.ttf');
      }

/*    @import url(https://fonts.googleapis.com/css?family=Yanone+Kaffeesatz);
      @import url(https://fonts.googleapis.com/css?family=Droid+Serif:400,700,400italic);
      @import url(https://fonts.googleapis.com/css?family=Ubuntu+Mono:400,700,400italic);*/

      body {
          font-family: 'Droid Sans';
      }

      h1, h2, h3 {
        /*font-family: 'Droid Serif';*/
          font-family: 'Yanone Kaffeesatz';
        font-weight: normal;
        color: rgb(0,56,201);
      }

      .center.middle h1 {
        color: rgb(0,156,146);
      }

      .remark-code, .remark-inline-code {
          font-family: 'Ubuntu Mono';
      }

      .titlepage p {
          margin: 5px;
      }

      strong {
        color: rgb(204,25,25);
      }

      img, video {
          margin: 5px;
          box-shadow: 3px 3px 5px 2px rgba(0,0,0,0.3);
      }

      img[alt^="logo"] {
          height: 60px;
          margin: 20px;
      }

      img[alt*="full:"] {
          width: 700px;
          float: right;
      }

      img[alt*="aneq:"] {
          width: 500px;
          float: right;
      }

      img[alt*="half:"] {
          width: 350px;
          float: right;
      }

      img[alt*="eof:"] {
          width: 450px;
          float: right;
      }

      img[alt*="nesting:"] {
          width: 500px;
          float: right;
      }

      img[alt*="twofig:"] {
          width: 360px;
      }

      table {
          border-collapse: collapse;
          margin: auto;
      }
      th, td {
          padding: 6px 13px;
          border: 1px solid #ccc;
      }
      table tr:nth-child(2n) {
          background-color: #f8f8f8;
      }

      img[alt*="right:"] {
          width: 500px;
          float: right;
      }


      .ms {
          color: red;
      }

      .obs {
          color: blue;
      }

      /* http://stackoverflow.com/questions/16311164/css-box-shadow-is-so-dark-when-printed*/
      @media print {
          img, video {
              box-shadow: none;
              -webkit-box-shadow: none;
          }
      }
    </style>
  </head>
  <body>
    <textarea id="source">

class: center, middle, titlepage

# Ensemble Kalman Filters in Nested Ocean Models

Alexander Barth<sup>1</sup>, Luc Vandenbulcke<sup>1,2</sup>,
Céline Taymans<sup>1</sup>,
Aida Alvera Azcárate<sup>1</sup> and Jean-Marie&nbsp;Beckers<sup>1</sup>


<sup>1</sup>University of Liège, Belgium

<sup>2</sup>seamod.ro, Romania

__Gordon Research Conference on Coastal Ocean Dynamics__

14 June 2017

![logo](Fig/copernicus.svg)
![logo](Fig/logo_ulg2.svg)
![logo](Fig/GHER.svg)

---
class: middle

# Outline

<div style="font-size: 1.5em">
  <li>Ensemble-based data assimilation</li>
  <li>Model error parametrization</li>
  <li>Model nesting in combination with data assimilation</li>
</div>

---
# Data assimilation
$\newcommand{\tindex}{n}$
$\renewcommand{\vec}{\mathbf}$
$\newcommand{\mat}{\mathbf}$

![nesting:](Fig/assim.svg)
* Combine observations and model in an __optimal way__
* Taking their __uncertainties/ errors__ into account

---
# Errors in observations

Errors in your observations might be due to

* __instrumental error__ (bias, drift, limited accuracy and precision)
* observation __processing error__

Observations might not represent exactly the same as the model variables

* mismatch in __resolved scales__
* mismatch in __resolved processes__
* ...

In some cases the observation operator can be relative complex and might also involve same approximation (and thus potential errors).

---
# Errors in an ocean model

* Errors in an ocean model might be due to

  * errors in __initial conditions__
  * errors in __open ocean boundary conditions__
  * errors in __atmospheric fields__ (wind, air temperature, ...)
  * errors in __bathymetry__
  * inappropriate __parametrizations__
  * __discretization__ error
  * ...

* It is essential to know how these uncertainties affect the results of the model.
* Data assimilation can be used 
  * to reduce the effect of these error sources, i.e. improve the knownlege of the ocean state 
  * or directly estimated the uncertain aspect of the model

---
# Propagation of uncertainty - Non-Gaussian errors

* __state vector__ $\mathbf x_n$: model results at a given time $t_n$
* __model__ $f_n$: model results at a given time $t_n$

$$
\mathbf x_{n+1} = f_n(\mathbf x_n) + \boldsymbol \eta
$$

* The vector $\boldsymbol \eta$ is the model error, often assumed to be a Gaussian distributed random vector with zero mean and error covariance noted $\mathbf Q$.

* The probability density $p(\mathbf{x},t)$ for the random vector $\mathbf{X}\_t$ satisfies the Fokker-Planck equation

<div>
$$
\frac{\partial p(\mathbf{x},t)}{\partial t} = \underbrace{-\sum_{i=1}^N \frac{\partial}{\partial x_i} \left[ f_i'(\mathbf{x}) p(\mathbf{x},t) \right]}_{\mbox{advection}}  + \underbrace{\sum_{i=1}^{N} \sum_{j=1}^{N} \frac{\partial^2}{\partial x_i \, \partial x_j} \left[ Q_{ij}(\mathbf{x}) p(\mathbf{x},t) \right]}_{\mbox{diffusion}}
$$
</div>

---
# Propagation of uncertainty - Non-Gaussian errors

  *  Even if the model is non-linear, the Fokker-Planck equation is
    linear in $p$!
  *  However, the "coefficients" of this differential equations are not constant.
  * __Impossible to solve__ for large geophysical problems
  *  If every dimension of $\mathbf x$ would be discretized with
    100 grid points, then pdf $p$ would represent $100^n$ numbers.
  *  Equation is similar to an advection-diffusion dimension in
    fluid dynamics (however in a very high dimensional space)
  *  If this equation represents the Eulerian view, what would be
    the equivalent Lagrangian view?

---
# Ensemble simulation

*  Lagrangian approach → ensemble simulation
*  In an ensemble simulation, a model is run a large number of times with different forcings, initial condition, parametrization,... within the uncertainty limit of the perturbed variable

|   | Eulerian approach | Lagrangian approach  |
|---|---|---|
| Fluid dynamics     | Navier-Stokes equations <span>$$\frac{\partial T}{\partial t} = - \nabla \cdot (\mathbf v T )  +  \nu \nabla^2 \mathbf T $$</span>  | Lagrangian fluid dynamics <span>$$\frac{d \mathbf x}{d t} = \mathbf v(\mathbf x)  + \mathbf w$$</span>|
| Error propagation  | Fokker-Planck equation <span>$$\frac{\partial p}{\partial t} = - \nabla \cdot (\mathbf f p )  + \nabla^2 ( \mathbf Q p )$$</span>    | Ensemble simulations  <span>$$\frac{d \mathbf x}{d t} = \mathbf f'(\mathbf x)  + \mathbf \eta$$</span>  |


*  The spread of the ensemble reflects the resulting uncertainty in the model results

---
# Ensemble simulation

![twofig:](Fig/ensemble_simulation_lorenz.png "Logo Title Text 1")
![twofig:](Fig/sandy.png "Logo Title Text 1")
* Ensemble simulation of the Lorenz model 1963
* Ensemble simulation for tracks of Hurricane Sandy by NCEP


---
# Error propagation (Gaussian case)

* Error propagation through an algebraic expression such like $\rho = \rho(T,S)$:

--
<div>
\begin{alignat*}{1}
\sigma^2_\rho &=
\left( \frac{\partial \rho}{\partial T} \right)^2
\sigma^2_T +
\left( \frac{\partial \rho}{\partial S} \right)^2
\sigma^2_S \\
&= \left(
\begin{array}{cc}
\frac{\partial \rho}{\partial T} & \frac{\partial \rho}{\partial S}
\end{array} \right)
\left(
\begin{array}{cc}
\sigma^2_T & 0 \\
0 & \sigma^2_S
\end{array} \right)
\left(
\begin{array}{c}
\frac{\partial \rho}{\partial T} \\
\frac{\partial \rho}{\partial S}
\end{array} \right)
\end{alignat*}
</div>

* For a model:

<div>
$$ \mathbf P_{\tindex+1} = \mathbf M_\tindex \mathbf P_\tindex \mathbf M_\tindex^T + \mathbf Q_\tindex
\quad \mbox{where} \; {M_\tindex}_{jj'} = \frac{\partial {f_\tindex}_j}{\partial x_{j'}} $$
</div>

* linear model: Kalman filter
* non-linear model: Extended Kalman filter (for error propagation the model is linearized)


---
# Analysis equation

![aneq:](Fig/illustrate_analysis_model.svg)
* probability density function (pdf) of the model state vector 
<div>
$$
p(\vec x) = A {\color{red}\exp( - (\vec x - \vec x^f)^T {\mat P^f}^{-1} (\vec x - \vec x^f))}
$$
</div>


---
# Analysis equation

![aneq:](Fig/illustrate_analysis_modelobs.svg)
* pdf of the <span class="ms">model state vector </span>
* pdf of the <span class="obs">observations given the model state vector</span> 
* Bayes rule:

<div>
$$
\begin{alignat*}{1}
p(\vec x | \vec y^o) = A' & \, {\color{red}\exp( - (\vec x^f - \vec x)^T {\mat P^f}^{-1} (\vec x^f - \vec x))} \\
& {\color{blue}\exp( - (\vec y^o - \mat H \vec x)^T {\mat R}^{-1} (\vec y^o - \mat H \vec x))}
\end{alignat*}
$$
</div>


---
# Analysis equation

![aneq:](Fig/illustrate_analysis.svg)
* product of two Gaussian pdf is also a Gaussian pdf

$$
p(\vec x | \vec y^o) = A' \, {\color{violet}\exp( - (\vec x - \vec x^a)^T {\mat P^a}^{-1} (\vec x - \vec x^a))}
$$

---
# EnKF and ETKF

![twofig:](Fig/illustrate_analysis_EnKF.svg)
![twofig:](Fig/illustrate_analysis_ETKF.svg)

* Ensemble Kalman Filter 
  * Ensemble of observations (i.e. perturbed observations)
  * More beneficial if ensemble size is very large
* Ensemble Transform Filter
  * No perturbations of observations
  * Minimal transformation of ensemble to match the covariance of the Kalman Filter
  * More beneficial for "moderate" ensemble size

---
# Kalman Filter and 4D-Var

|  | Ensemble Kalman Filter |             4D-Var |
|--|------------------------|--------------------|
| error estimation | Explicit  | Implicit (Hessian matrix) |
| used data        | past data | all data |
| issues with non-linear model | assumes Gaussian-distributed data during the analsis | possibly local minima during optimization  |
| Practical issues                             | need for localization | unbounded senstivity |

![full:](Fig/enkf_4dvar.svg)

---
# Why do we need localization?

 * In ensemble assimilation schemes, the model error covariance $\mathbf P$ is represented by an __ensemble of model states__ $\mathbf x^{(k)},k=1,\dots,N$ ($\langle \dot \rangle$ is the ensemble average).
 
$$ \mathbf P = \langle(\mathbf x - \langle\mathbf x\rangle) (\mathbf x - \langle\mathbf x\rangle)^T \rangle = \mathbf S \mathbf S^T$$

 * As $N$ increases __convergence is relatively slow__ ($N^{-1/2}$) $\rightarrow$ sampling error.
 * For realistic ocean systems, only a relatively small number of ensemble members can be calculated.
 * This sampling error leads to __unrealistic long-range correlations__.
 * Covariance localization suppresses these long-range correlations based on the horizontal distance relative to a __specified length-scale__.

---
# Sampling error and assimilation of a point measurement

 * Problematic spurious long-range correlations can be highlighted easily when assimilating a point measurement.

![right:](Fig/temp_incement_global1.png)
   * Correction will be proportional to the covariance between the state vector at the observed location and all other model grid points
   * Velocity covariance between location marked by the magenta circle and other model grid points

---
# Issues with localization

 * __Ad-hoc approach__ introduced by analogy to optimal interpolation (where it is done for computational reasons).
 * It can __filter out realistic long-range correlations__ (for example introduced through error in atmospheric fields).
 * Spurious correlations between __weakly related model variables__ that are close-by might not be filtered (in particular in coupled models).
 * Which length-scale to use when __multiple processes with different scales__ are present?

---
# Analysis with sub-optimal gain

 * The analysis error covariance for any gain matrix can be written as a sum of:
    * error decrease thanks to the observations
    * error increase if the gain is not optimal

<div>
$$
  \begin{eqnarray*}
\mathbf P^a &=& \mathbf P^f  
 - \underbrace{\mathbf K \mathbf H \mathbf P^f}_{\mbox{error reduction}}  \\
&& + 
\underbrace{
(\mathbf K - \mathbf K') 
( \mathbf H \mathbf P \mathbf H^T + \mathbf R ) 
(\mathbf K - \mathbf K')^T
}_{\mbox{error increase}}    
  \end{eqnarray*}
$$
</div>

---
# Approach

The method similar to __bootstrapping__ in statistics:

 * A __relatively large ensemble__ of e.g. 100 members is created by perturbed initial conditions, boundary conditions,...
 * The ensemble is __split in 2 sub-ensembles__ of 50 members (at random)
 * The observations are assimilated with the 2 sub-ensembles of 50 members 

We do not have access to the optimal Kalman gain, but the Kalman gain error can be approximated in average by difference from analisis based on these sub-ensembles.

 * The __difference between the two analyses increment__ is computed.

The covariance of this difference is represents the error increase due to an imperfect Kalman gain.
 * Repeated these steps with other 2 sub-ensembles.
 * We check where the analyses are consistent in all tests: __variance of the increment__.
 * The localization function is built based on the __consistency of the analysis__.

To ensure smooth variations in space, all terms of this equation are __filtered spatially__.
 * The analysis increment is multiplied element-by-element with this localization function
    


We do not account for:
 * statistical fluctuations are based on an ensemble of half the size.
 * all realizations of the increment fluctuations use the same ensemble.

---

# Observations in the interior of the domain

<p>
  <img src="Fig/increment-50-50.png" alt="twofig:" style="width: 340px; float: left">
  <img src="Fig/stdincrement-50-50.png" alt="twofig:" style="width: 340px; float: left">
  <img src="Fig/locenv-50-50.png" alt="twofig:" style="width: 340px; float: left">
  <div style="width: 340px; float: left">
    <ul>
      <li>Observation located at 8.8250 W and 43.3250 N</li>
      <li>Significant spurious long-range correlation, especially with
      parts of the domain having a large error variance</li>
    </ul>
</div>
</p>

---

# Observations in a highly variable area

<p>
  <img src="Fig/increment-100-80.png" alt="twofig:" style="width: 340px; float: left">
  <img src="Fig/stdincrement-100-80.png" alt="twofig:" style="width: 340px; float: left">
  <img src="Fig/locenv-100-80.png" alt="twofig:" style="width: 340px; float: left">
  <div style="width: 340px; float: left">
    <ul>
      <li>Covariance is more localized at this location, but spurious corrections are still present</li>
    </ul>
</div>
</p>



---
# Representation the the model error


* Specifying the error covariance accurately is crucial
* "Garbage in, garbage out"
* Little is known about __the model error covariance__
* If the model error is not taken into account, then the strength of the relationship between different model parameters tends to be over-estimated
* → Degradation of unobserved model variable
* What can we learn about the model error when we use __nested models__?

---
# Model nesting

![right:](Fig/1-way.png)
* __1-way nesting__
* Boundary conditions from the large-scale model are extracted and applied to the nested model
* The large-scale model is __independent__ from the nested model

---
# Model nesting

![right:](Fig/2-way.png)
* __2-way nesting__
* Boundary conditions from the large-scale model are extracted and applied to the nested model
* The large-scale receives the spatially averaged fields from the nested model (__feedback__)
* Effectively, in the overlapping region the model equations are solved:
  * on low-resolution grid (large-scale model)
  * a high-resolution grid (nested model)
* The solution of the low-resolution grid is typically discarded and replaced by the solution from the nested model


---
# Opportunity and objective

* The nesting frame-work can give us some insight about the __model error due to resolution__
* Objective: Derive an __empiric stochastic parametrization of subgrid-scale processes__
* Model uncertainties are usually represented by a additive random term in the evolution equation
* For example in the temperature equation

$$
T\_{n+1} = f_T(T\_n,...) + \eta_T
$$

* This random term should account for:
  * error in forcing fields
  * error in model parameters
  * error in model parametrizations
  * structural model error in particular due to resolution
* Except the uncertain forcing fields error and model parameters, this term is often omitted because not much is known about the model errors


---
# Traditional subgrid-scale parametrization

* Turbulence closure → essentially along the vertical processes
* Horizontal processes:
 * Laplacian diffusion
$$
\frac{\partial T}{\partial t} = ... + \kappa_1 \nabla^2 T
$$
$\kappa_1$ is either constant or depends on the gradient of the flow (Smagorinsky, 1963) (in the later case rather $\nabla ( \kappa_1 \nabla T)$).

 * biharmonic diffusion

$$
\frac{\partial T}{\partial t} = ... - \kappa_2 \nabla^4 T
$$

* __Deterministic subgrid-scale parametrization__
* Represents the __mean effect__ of subgrid-scale processes

---
# Approach

* During the feedback compute the difference between the coarse model grid and the averaged fine model result, called "feedback increment" (Fi)
* The feedback increment for temperature:
$$
T\_{Fi} = T\_\mbox{average of fine grid} - T\_\mbox{coarse grid}
$$

* The temperature equations of coarse grid model can be written as:

$$
T\_{n+1} = f(T\_n) + T\_{Fi}
$$

* The feedback increment is diagnosed:
   * instantaneous value every 12 hours
   * mean over 12 hours
   * standard deviation of 12 hours
* Feedback increment for: temperature, salinity, u and v velocity component


---
# Model

* Ligurian Sea nested in the CMEMS Copernicus Mediterranean Model (one-way)
* High-resolution NW Corsican model nesting in the Ligurian Sea model (two-way)
* Resolutions:
  * Ligurian Sea model: 1/60 degree (about 1.6 km, time step 150 s)
  * NW Corsican model: 1/180 degree (about 530 m, time step 50 s)
* Nesting ratio 3
* ERA Interim fluxes

![full:](Fig/nesting_system-v2.svg "Logo Title Text 1")


---

# SAR
![full:](Fig/SAR_LigurianSea.svg "Logo Title Text 1")

Envisat, SAR data, 2012-03-16, Karimova S., 2017


---
# Surface salinity

<video src="Fig/SSS-2.mp4" style="width: 550px; float: right" autoplay="autoplay" loop="loop" controls="controls">
* Inside rectange: solution of the nested model
* Eddies and filements are not noticably affected by the model boundary
* Match of bathymetry is important near the boundary
* Avoid abrupt bathymetry changes in the nested model near the boundary
* Otherwise: spurious upwelling
* Rossby radius of deformation: ~4 - 10 km; baroclinic instabilities
---
# Surface temperature

![twofig:](Fig/SST-0021.png "")
![twofig:](Fig/ls_plot_viirs.png "")

* VIIRS L3 on an exceptionally clear day
* Overall good match
* ECMWF ERA Interim flux
* Small-scale structures seen in VIIRS at comparable locations in the model run
---

# Model RMS error

![right:](Fig/Spinup2016-nest-u3hadv_dt150/comp_sst_viirs2.png)
* Only night-time
* Comparison with L3 satellite data
* Variability in part due to the variable coverage


---
# Second level of nesting

<video src="Fig/SST-2grid.mp4" style="width: 500px; float: right" autoplay="autoplay" loop="loop" controls="controls">
* Rich fine scale structures:
 * Filaments
 * Eddies
* Clear diurnal heating signal
* Again a nesting ratio of 3, reaching about 180 m resolution
* Master Thesis of Céline Taymans

---
# Explore the spatial structure

![eof:](Fig/eof-mean-salt.png "Logo Title Text 1")
* EOF decomposition (salinity feed-back increment)
* For salinity the EOF power spectrum is quite flat
* First EOF modes accounts __only for 6% __ of the variance
* EOF decomposition is not very useful here


---
# EOF decomposition
![eof:](Fig/eof-mean-u.png "Logo Title Text 1")
* For velocity, the first mode accounts for __about 50% __ of the variability
* Structure quite similar to waves following the coastline
* Here $u$ component is shows, the $v$ behaves similarly

---
## Temporal structure: tracers

* Auto-correlation of instantaneous field at the time resolution 12 hours
* Computed using Fast Fourier Transformation
* Auto-correlation at a fixed location (8.758333, 42.725)
* No temporal correlation for temperature and salinity

![twofig:](Fig/autocorr-temp-27-20.svg "Logo Title Text 1")
![twofig:](Fig/autocorr-salt-27-20.svg "Logo Title Text 1")


---
## Temporal structure: velocity

* However significant temporal correlation for $u$ and $v$ velocity

![twofig:](Fig/autocorr-u-27-20.svg "Logo Title Text 1")
![twofig:](Fig/autocorr-v-27-20.svg "Logo Title Text 1")

---
# Stochastic parametrization

* Can we __(partially) "predict"__ the statistical properties of the feed-back increment from the fields of the coarse resolution model?
* Linear (or non-linear) __regression__ between:
   * __Feedback increment__: difference of the high-resolution and low-resolution model (based on the feedback)
   * __low-resolution model variables__
* Test case:
   * 1 month spin-up of the Ligurian Sea model starting 1st January 2015
   * Simulation starting the 1st February to the 30th June 2015 of the two-way nested system
* Divide simulation between:
    * __training data set__ (all except the last 25 days)
    * __validation data set__ (the last 25 days)
* Determine the optimal coefficients on the training data set
* Compute the fraction of explained variance on the validation data set
* Restricted to the surface


---
# Regression

* __Linear regression__:
$$
y = \beta_1 x_1 + \beta_2 x_2 + ... + \epsilon,
$$
where
   * $y$ is a statistical property of the feed-back increment (such as mean or standard deviation) of different model variables ($T$, $S$, $u$ or $v$),
   * $x_1$,...$x_2$ "explaining" variable of the coarse grid model and
   * $\beta_1$, $\beta_2$, ... coefficients to be determined by regression
   * $\epsilon$ is the error to be minimized
   * $y$, $x_1$, and $x_2$... depend on space and time, but the coefficients not.

* __Non-linear regression__:
$$
y = \beta_1 x_1^{n_1} + \beta_2 x_2^{n_2} + ... \epsilon,
$$
where
   * $n_1$, $n_2$,... are (possibly fractional) exponents


---
# Motivating example


![twofig:](Fig/std-temp-4.png "Logo Title Text 1")
![twofig:](Fig/temp-4.png "Logo Title Text 1")

<div style="clear: both">

* Surface temperature
* Standard deviation of the feedback increment is relatively high right next to the coast
* Large standard deviation of the feedback increment related to fonts



---
# Motivating example

![twofig:](Fig/std-temp-4.png "Logo Title Text 1")
![twofig:](Fig/stdrec-temp-4.png "Logo Title Text 1")

<div style="clear: both">

* Result of a linear regression
* Here $y$ is the standard deviation of the feed-back difference
* $x\_1$ absolute value of the temperature Laplacian:
$$
std(T\_{Fi}) = \beta_1 |\nabla T|
$$

* Reasonable correspondence of the structures
* More fine-scale structure in reconstructions using the Laplacian

---
# Motivating example

![twofig:](Fig/std-temp-4.png "Logo Title Text 1")
![twofig:](Fig/stdrecf-temp-4.png "Logo Title Text 1")

<div style="clear: both">

* Spatially filtered Laplacian $\cal F [|\nabla T|]$ implemented by a horizontal diffusion
$$
std(T\_{Fi}) = \beta_1 \cal F [|\nabla T|]
$$

* Surprisingly good correspondence

---
# Quantitative assessment

* The to be "predicted" variable $y$ can be decomposed into
$$
y = y_{reg} + \epsilon
$$

* For a useless regression: the variance of the residual $\epsilon$ is as large as the variance of the to be "predicted" variable $y$
* Let's define the __fraction of explained variance__:

$$
r^2 = 1 - \frac{ \sum\_{i} {\epsilon}\_i^2 }{\sum\_{i} y\_i^2}
$$


---
# Variability of the feed-back difference

* standard deviation of the $u$ velocity component
* __Linear-fit__:

|            | explained variance |         lap. coef. |      biharm. coef.|
|---|---|---|---|
|        lap. |     0.19455 |     0.01655 |          --|
|     biharm. |     0.17482 |          -- |     0.01177|
| lap.+biharm. |     0.19565 |     0.01149 |     0.00299|


* __Non-linear fit__:

|            | explained variance |         lap. coef. |    lap. expo. |      biharm. coef. | biharm. expo.|
|---|---|---|---|---|---|
|        lap. |     0.45202 |     0.00227 |     0.28716 |          -- |          --|
|     biharm. |     0.49529 |          -- |          -- |     0.00162 |     0.23030|
| lap+biharm. |     0.49604 |     0.00162 |     0.23040 |     0.50879 |   158.31475|



* Similar conclusion for the $v$ velocity
---
# Tracers

* __Salinity__

|            | explained variance |         lap. coef. |      biharm. coef.|
|---|---|---|---|
|        lap. |     0.39232 |     0.00347 |          --|
|     biharm. |     0.39054 |          -- |     0.00347|
| lap+biharm. |     0.42329 |     0.00201 |     0.00163|

* __Temperature__

|            | explained variance |         lap. coef. |      biharm. coef.|
|---|---|---|---|
|        lap. |     0.43098 |     0.00671 |          --|
|     biharm. |     0.42384 |          -- |     0.00532|
| lap+biharm. |     0.44675 |     0.00407 |     0.00228|

* non-linear fit is not significantly better


---
# Nesting and data assimilation

![full:](Fig/assim_nesting2.svg)

* State vector combines coarse and fine mode grid
* Results does not change if the state vector contains the overlapping region or not
---
# Nesting and data assimilation

![full:](Fig/assim_nesting3.svg)
* Domain localization: the analysis equation is solved for every water column individually using only nearby observations

---
# Nesting and data assimilation

![full:](Fig/ls_obs_impact.png)
* Consistent model update across nesting boundary

---
# Ensemble generation

![half:](Fig/wind_ens.svg)
* 100 ROMS model runs with perturbed:
  * Boundary conditions
  * Wind forcing
  * Solar radiation
* Ensemble run is the most costly step
* For Ensemble OI: the ensemble is static taken from the time evolution of the model
* Here: ensemble is from a free-running ensemble simulation

---
# Ensemble standard deviation

![right:](Fig/ls_plot_sst_std.png)
* Ensemble method privide an error of the forecast and the analysis
* Matching the region with intense mesoscale flow
* Perturbations at the model boundary probably too small

---
# In situ measurements

![nesting:](Fig/ls_coriolis_overview.png)

Glider deployments
* CMRE, Italy (LOGMEC16, Ines Borrione, Paolo Oddo, Aniello Russo, and Emanuel Coelho, 2017)
* OOV-LOV, France (MooseT00)

---
# RMS error between model and glider

![right:](Fig/ls_plot_rms_prof_temp.svg)
* Ensemble generation:
   * Perturbed boundary and wind forcings
* (As expected, the analysis reduces the RMS error)
* Also an improvement of the model results during forecast

---
# Model nesting with "upscaling"

![nesting:](Fig/upscaling.png)
* Boundary conditions from the large-scale model are extracted and applied to the nested model
* The results from the high-resolution model are __assimilated__ in the large-scale model
* Stochastic parametrization of model error related to limited resolution would be beneficial in this context

---
# Model nesting with "upscaling"


![full:](Fig/upscaling_sst_med_lig.svg)

* NEMO model run, 1 February 2014

---
# First results of model upscaling

![full:](Fig/sst_rms_upscaling.png)
* Local Ensemble Transform Kalman Filter with 30 km localization scales
* Work by Luc Vandenbulcke

---
# Conclusions

* For two-way nested models, the model equations are solved __twice__ in the overlapping region with different resolution
* The feedback increment allow us to tell something about the __model error due to the limited of resolution__
* Statistical properties of the error term can be derived
* This error term can be parametrized in terms of the Laplacian and biharmonic diffusion
* Coefficients of this statistical parametrization can be obtained by regression
  * Biharmonic diffusion operator not really needed
  * Linear-fit is sufficient for tracers, while velocity component non-linear fit is beneficial
* To a certain degree these coefficients are expected to be independent of the domain
* The consistency in a nested model system is maintained by using a state vector combining all grids
* Upscaling: emulating the __feedback by data assimilation__

---
# Challenges in data assimilation

* Non-linear and __non-Gaussian__ systems
* Incorporate __new data types__ from remote sensing and in situ platforms (HF radars, sea-surface salinity, wide-swath altimetry, ...).
  * Which processes are __resolved__
  * How to __represent the error__ of the observations
* Adapt assimilation schemes for __complex coupled models__
* Ensemble simulations:
  * __identification of the origin of model errors__ (e.g. uncertain forcing fields, parameters,...),
  * __parametrization those errors__,
  * potential to provide meaningful error estimates on model products (and derived products).
* What do we __learn__ form data assimilation to:
  * improve our models (reducing systematic and random errors),
  * identify errors in our forcing fields (atmospheric parameters, open-ocean boundary conditions,...), and
  * enhance the observational network?
* Develop __robust__ and __efficient__ methods suitable for operational use


    </textarea>
    <script src="remark-latest.min.js" type="text/javascript"></script>
    <!--<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML&delayStartupUntil=configured" type="text/javascript"></script>-->
    <script src="MathJax-2.6-latest/MathJax.js?config=TeX-AMS_HTML&delayStartupUntil=configured" type="text/javascript"></script>

    <!--<script src="mathjax/MathJax.js" type="text/javascript"></script>-->
    <script type="text/javascript">
      var slideshow = remark.create();

      // Setup MathJax
      MathJax.Hub.Config({
          tex2jax: {
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
            inlineMath: [['$','$'], ['\\(','\\)']],
            processEscapes: true
          },
          TeX: { extensions: ["color.js"] }
      });
      MathJax.Hub.Configured();

    </script>
  </body>
</html>

<!--  LocalWords:  Slideshow nd matlab argo whos Attr Tobs latobs UTC
 -->
<!--  LocalWords:  lonobs timeobs datenum datevec datestr colorbar nc
 -->
<!--  LocalWords:  caxis Outliers outliers Bathymetry GEBCO ncdisp pn
 -->
<!--  LocalWords:  bathymetry ncread lon ndgrid pcolor divand Tmean
 -->
<!--  LocalWords:  Tanom len moddim interpn isnan repmat po lentime
 -->
<!--  LocalWords:  clf dpng yyyy png outlier OceanBrowser url rgb px
 -->
<!--  LocalWords:  Kaffeesatz titlepage img rgba CDI situ Sylvain OGS
 -->
<!--  LocalWords:  Watelet Troupin Alvera Azcarate Giorgio Santinelli
 -->
<!--  LocalWords:  Gerrit Hendriksen Alessandra Giorgetti Beckers EPS
 -->
<!--  LocalWords:  GHER Liège SOCIB Deltares Variational gridded SMHI
 -->
<!--  LocalWords:  variational NetCDF SeaDataNet EMODNET Metadata SVG
 -->
<!--  LocalWords:  OPeNDAP Centred WebM revalidation distrib EDMO OGC
 -->
<!--  LocalWords:  oceanbrowser abarth localhost webm AGPL matplotlib
 -->
<!--  LocalWords:  WMS WFS twofig td ccc webkit parametrization Luc
 -->
<!--  LocalWords:  Vandenbulcke seamod ro subgrid parametrizations Fi
 -->
<!--  LocalWords:  ROMS Ligurian CMEMS EOF Laplacian nabla frac mbox
 -->
<!--  LocalWords:  biharm discretization altimetry mathbf covariance
 -->
<!--  LocalWords:  Smagorinsky biharmonic stdfit parametrized src eof
 -->


<!--  LocalWords:  Yanone submesoscale aneq Kalman Céline Taymans vec
 -->
<!--  LocalWords:  Azcárate newcommand tindex renewcommand underbrace
 -->
<!--  LocalWords:  advection ij boldsymbol discretized pdf Eulerian
 -->
<!--  LocalWords:  rightarrow forcings Navier Stoques cdot NCEP jj
 -->
<!--  LocalWords:  alignat linearized ETKF SAR Envisat Karimova VIIRS
 -->
<!--  LocalWords:  ECMWF CMRE LOGMEC Borrione Paolo Oddo Aniello OOV
 -->
<!--  LocalWords:  Coelho LOV MooseT upscaling NEMO coef
 -->
